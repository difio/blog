<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tips | Monupco]]></title>
  <link href="http://monupco.com/blog/categories/tips/atom.xml" rel="self"/>
  <link href="http://monupco.com/blog/"/>
  <updated>2012-04-06T11:39:03+03:00</updated>
  <id>http://monupco.com/blog/</id>
  <author>
    <name><![CDATA[Monupco Team]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[OpenShift Cron Takes Over Celerybeat]]></title>
    <link href="http://monupco.com/blog/2012/03/14/openshift-cron-takes-over-celerybeat/"/>
    <updated>2012-03-14T20:48:00+02:00</updated>
    <id>http://monupco.com/blog/2012/03/14/openshift-cron-takes-over-celerybeat</id>
    <content type="html"><![CDATA[<p><a href="http://celeryproject.org/"><em>Celery</em></a> is an asynchronous task queue/job queue
based on distributed message passing. You can define tasks as Python functions,
execute them in the background and in a periodic fashion.
<a href="http://monupco.com"><em>Monupco</em></a> uses <em>Celery</em> for virtually everything.
Some of the tasks are scheduled after some event takes place (like user pressed a button)
or scheduled periodically.</p>

<p><em>Celery</em> provides several components of which <em>celerybeat</em> is the periodic task scheduler.
When combined with <a href="http://djangoproject.com"><em>Django</em></a> it gives you a very nice admin interface
which allows periodic tasks to be added to the scheduler.</p>

<h2>Why change</h2>

<p><em>Monupco</em> has relied on <em>celerybeat</em> for a couple of months. Back then, when <em>Monupco</em> launched,
there was no cron support for OpenShift so running <em>celerybeat</em> sounded reasonable.
It used to run on a dedicated virtual server and for most of the time that was fine.</p>

<p>There were a number of issues which <em>Monupco</em> faced during its first months:</p>

<ul>
<li><p><em>celerybeat</em> would sometime die due to no free memory on the virtual instance.
When that happened no new tasks were scheduled and data was left unprocessed.
Let alone that higher memory instance and the processing power which comes with it
cost extra money.</p></li>
<li><p><em>Monupco</em> is split into several components which need to have the same code base
locally - the most important are database settings and the periodic tasks
code. At least in one occasion <em>celerybeat</em> failed to start because of a buggy
task code. The offending code was fixed in the application server on OpenShift but
not properly synced to the <em>celerybeat</em> instance. Keeping code in sync is a priority
for distributed projects which rely on <em>Celery</em>.</p></li>
<li><p><em>Celery</em> and <em>django-celery</em> seem to be updated quite often. This poses a significant risk
of ending up with different versions on the scheduler, worker nodes and the app server. This will
bring the whole application to a halt if at some point a backward incompatible change is introduced
and not properly tested and updated. Keeping infrastructure components in sync can be a big challenge
and I try to minimize this effort as much as possible.</p></li>
<li><p>Having to navigate to the admin pages every time I add a new task or want to change the execution
frequency doesn't feel very natural for a console user like myself and IMHO is less productive.
For the record I primarily use <em>mcedit</em>. I wanted to have something more close to the
write, commit and push work-flow.</p></li>
</ul>


<h2>The take over</h2>

<p>It's been some time since OpenShift
<a href="https://www.redhat.com/openshift/community/blogs/getting-started-with-cron-jobs-on-openshift">introduced</a>
the cron cartridge and I decided to give it a try.</p>

<p>The first thing I did is to write a simple script which can execute any task from the monupco.tasks module
by piping it to the Django shell (a Python shell actually).</p>

<pre><code>$ cat run_celery_task 

#!/bin/bash
#
# Copyright (c) 2012, Alexander Todorov &lt;atodorov@nospam.otb.bg&gt;
#
# This script is symlinked to from the hourly/minutely, etc. directories
#
# SYNOPSIS
#
# ./run_celery_task cron_search_dates
#
# OR
#
# ln -s run_celery_task cron_search_dates
# ./cron_search_dates
#

TASK_NAME=$1
[ -z "$TASK_NAME" ] &amp;&amp; TASK_NAME=$(basename $0)

if [ -n "$OPENSHIFT_APP_DIR" ]; then
    source $OPENSHIFT_APP_DIR/virtenv/bin/activate
    export PYTHON_EGG_CACHE=$OPENSHIFT_DATA_DIR/.python-eggs
    REPO_DIR=$OPENSHIFT_REPO_DIR
else
    REPO_DIR=$(dirname $0)"/../../.."
fi

echo "import monupco.tasks; monupco.tasks.$TASK_NAME.delay()" | $REPO_DIR/wsgi/monupco/manage.py shell
</code></pre>

<p>This is a multicall script which allows symlinks with different names to point to it.
Thus to add a new task to cron I just need to make a symlink to the script from one of the
hourly, minutely, daily, etc. directories under cron/</p>

<p>The script accepts a parameter as well which allows me to execute it locally for debugging purposes
or to schedule some tasks out of band.</p>

<p>This is how it looks like on the file system:</p>

<pre><code>$ ls -l .openshift/cron/hourly/
some_task_name -&gt; ../tasks/run_celery_task
another_task -&gt; ../tasks/run_celery_task
</code></pre>

<p>After having done these preparations I only had to embed the cron cartridge and git push to OpenShift:</p>

<pre><code>rhc-ctl-app -a monupco -e add-cron-1.4 &amp;&amp; git push
</code></pre>

<h2>What's next</h2>

<p>At present OpenShift can schedule your jobs every minute, hour, day, week or month and does so using the
<em>run-parts</em> script. You can't schedule a script to execute at 4:30 every Monday or every 45 minutes for example.
See <a href="https://bugzilla.redhat.com/show_bug.cgi?id=803485">rhbz #803485</a> if you want to follow the
progress. Luckily <em>Monupco</em> doesn't use this sort of job scheduling for the moment.</p>

<p><em>Monupco</em> is scheduling periodic tasks from OpenShift cron for a few days already.
It seems to work reliably and with no issues. One less component to maintain and worry about.
More time to write code.</p>

<hr />

<p><a href="http://about.me/atodorov"><em>Alexander Todorov</em></a> is Monupco's founder and lead developer!</p>

<p>For an insight of available updates to you OpenShift applications give
Monupco a <a href="https://monupco-otb.rhcloud.com/applications/mine/">try</a>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to get to the OpenShift shell]]></title>
    <link href="http://monupco.com/blog/2012/03/09/how-to-get-to-the-openshift-shell/"/>
    <updated>2012-03-09T21:43:00+02:00</updated>
    <id>http://monupco.com/blog/2012/03/09/how-to-get-to-the-openshift-shell</id>
    <content type="html"><![CDATA[<p>I wanted to examine the Perl environment on OpenShift and got tired of making snapshots,
unzipping the archive and poking through the files. I wanted a shell. Here's how to get one.</p>

<ol>
<li><p>Get the application info first</p>

<pre><code> $ rhc-domain-info 
 Password: 
 Application Info
 ================
 myapp
     Framework: perl-5.10
      Creation: 2012-03-08T13:34:46-04:00
          UUID: 8946b976ad284cf5b2401caf736186bd
       Git URL: ssh://8946b976ad284cf5b2401caf736186bd@myapp-mydomain.rhcloud.com/~/git/myapp.git/
    Public URL: http://myapp-mydomain.rhcloud.com/

  Embedded: 
       None
</code></pre></li>
<li><p>The Git URL has your username and host</p></li>
<li><p>Now just ssh into the application</p>

<pre><code> $ ssh 8946b976ad284cf5b2401caf736186bd@myapp-mydomain.rhcloud.com

     Welcome to OpenShift shell

     This shell will assist you in managing OpenShift applications.

     !!! IMPORTANT !!! IMPORTANT !!! IMPORTANT !!!
     Shell access is quite powerful and it is possible for you to
     accidentally damage your application.  Proceed with care!
     If worse comes to worst, destroy your application with 'rhc app destroy'
     and recreate it
     !!! IMPORTANT !!! IMPORTANT !!! IMPORTANT !!!

     Type "help" for more info.

 [myapp-mydomain.rhcloud.com ~]\&gt; 
</code></pre></li>
</ol>


<p><strong>Voila!</strong></p>

<hr />

<p><a href="http://about.me/atodorov"><em>Alexander Todorov</em></a> is Monupco's founder and lead developer!</p>

<p>For an insight of available updates to you OpenShift applications give
Monupco a <a href="https://monupco-otb.rhcloud.com/applications/mine/">try</a>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to update dependencies on OpenShift]]></title>
    <link href="http://monupco.com/blog/2012/02/18/how-to-update-dependencies-on-openshift/"/>
    <updated>2012-02-18T01:00:00+02:00</updated>
    <id>http://monupco.com/blog/2012/02/18/how-to-update-dependencies-on-openshift</id>
    <content type="html"><![CDATA[<p>If you are already running some cool application on <a href="http://openshift.redhat.com">OpenShift</a>
it could be the case that you have to update some of the packages installed as dependencies.
Here is an example for an application using the python-2.6 cartridge.</p>

<h2>Pull latest upstream packages</h2>

<p>The most simple method is to update everything to the latest upstream versions.</p>

<ol>
<li><p>Backup! Backup! Backup!</p>

<pre><code> rhc-snapshot -a mycoolapp
 mv mycoolapp.tar.gz mycoolapp-backup-before-update.tar.gz
</code></pre></li>
<li><p>If you haven't specified any particular version in <code>setup.py</code> it will
look like this:</p>

<pre><code>  ...
  install_requires=[
                  'monupco-openshift-express-python',
                  'MySQL-python',
                  'Markdown',
                 ],
  ...
</code></pre></li>
<li><p>To update simply push to OpenShift instructing it to rebuild your virtualenv:</p>

<pre><code> cd mycoolapp/
 touch .openshift/markers/force_clean_build
 git add .openshift/markers/force_clean_build
 git commit -m "update to latest upstream"
 git push
</code></pre></li>
</ol>


<p>Voila! The environment hosting your application is rebuilt from scratch.</p>

<h2>Keeping some packages unchanged</h2>

<p>Suppose that before the update you have <code>Markdown-2.0.1</code> and you want to keep it!
This is easily solved by adding versioned dependency to <code>setup.py</code></p>

<pre><code>    -       'Markdown',
    +       'Markdown==2.0.1',
</code></pre>

<p>If you do that OpenShift will install the same <code>Markdown</code> version when rebuilding your
application. Everything else will use the latest available versions.</p>

<p><strong>Note:</strong> after the update it's recommended that you remove the
<code>.openshift/markers/force_clean_build</code> file. This will speed up the push/build process
and will not surprise you with unwanted changes.</p>

<h2>Update only selected packages</h2>

<p>Unless your application is really simple or you have tested the updates, I suspect that
you want to update only selected packages. This can be done without rebuilding the whole
virtualenv. Use versioned dependencies in <code>setup.py</code> :</p>

<pre><code>    -       'Markdown==2.0.1',
    -       'django-countries',
    +       'Markdown&gt;=2.1',
    +       'django-countries&gt;=1.1.2',
</code></pre>

<p>No need for <code>force_clean_build</code> this time. Just</p>

<pre><code>    git commit &amp;&amp; git push
</code></pre>

<p>At the time of writing my application was using <code>Markdown-2.0.1</code> and <code>django-countries-1.0.5</code>.
Then it updated to <code>Markdown-2.1.1</code> and <code>django-countires-1.1.2</code> which also happened to be
the latest versions.</p>

<p><strong>Note:</strong> this will not work without <code>force_clean_build</code></p>

<pre><code>    -       'django-countries==1.0.5',
    +       'django-countries',
</code></pre>

<h2>Warning</h2>

<p>OpenShift uses a local mirror of <a href="http://pypi.python.org">Python Package Index</a>.
It seems to be updated every 24 hours or so. Have this in mind if you want to update
to a package that was just released. It will not work!</p>

<hr />

<p><a href="http://about.me/atodorov"><em>Alexander Todorov</em></a> is Monupco's founder and lead developer!</p>

<p>For an insight of available updates to you OpenShift applications give
Monupco a <a href="https://monupco-otb.rhcloud.com/applications/mine/">try</a>!
It keeps generating new <a href="http://monupco.com/advisories/">advisories</a> every day!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to write a registration agent for Monupco]]></title>
    <link href="http://monupco.com/blog/2012/02/11/how-to-write-registration-agent-for-monupco/"/>
    <updated>2012-02-11T00:32:00+02:00</updated>
    <id>http://monupco.com/blog/2012/02/11/how-to-write-registration-agent-for-monupco</id>
    <content type="html"><![CDATA[<p><a href="http://monupco.com">Monupco</a> is aiming to support a broad range of PaaS and
cloud vendors but that takes time. If your favorite PaaS platform is not
already supported here's how you can help.</p>

<p>The registration agent is very simple and serves only a single purpose -
to build a list of installed software and send it to the server.</p>

<p>Some general considerations first:</p>

<ul>
<li><p>Your code should be open source! Preferably licensed under the MIT or BSD license;</p></li>
<li><p>Whenever possible use the native programming language for the platform - if writing
an agent for PHP PaaS use PHP, if writing for Node.JS use JavaScript, etc;</p></li>
<li><p>All registration agents are bundled as packages so that they can install natively
on the platform. For Python it is a package from PyPI, for PHP it will be a PEAR package,
etc. Develop your agent as a package;</p></li>
<li><p>Naming convention for registration agent is <strong>monupco-&lt;vendor>-&lt;language></strong>. For example
<code>monupco-openshift-express-python</code>, <code>monupco-dotcloud-nodejs</code>. If you have common code,
for example the package management part, it can be split into separate module named
<strong>common-&lt;language>-monupco</strong>.</p></li>
<li><p>Registration agents are specific to vendor and programming language. This is because
different PaaS vendors provide the information in a different way. This makes code easier
to maintain and easier for end-users to find the proper registration agent later;</p></li>
<li><p>Vendor ID and package type ID numbers are unique. It is important to use the correct IDs.
They allow proper identification of applications and packages stored in the database.
Different types of data also require different processing. Tell us for which vendor/language
you would like to contribute a registration agent and we will reserve the IDs for you;</p></li>
<li><p>We will also setup a development server so you can safely test the application
registration/update process. Just let us know you need one.</p></li>
</ul>


<p>Once you have the ID allocation and development server you can start writing some code.</p>

<ul>
<li><p>Your code should create the following data structure:</p>

<pre><code>  {
      'user_id'    : integer,
      'app_name'   : string,
      'app_uuid'   : string,
      'app_type'   : string,
      'app_url'    : string,
      'app_vendor' : integer,
      'pkg_type'   : integer,
      'installed'  : list of {'n' : string, 'v' : string, 't' : integer}
  }
</code></pre></li>
</ul>


<p>Fields are defined as follow:</p>

<ul>
<li><p>user_id - integer - the ID of the user at Monupco website. All applications registered under
the same user_id will be visible only to that user. You can view your UserID
<a href="https://monupco-otb.rhcloud.com/profiles/mine/">here</a>. It is important that this value is not
hard-coded but read from ENV variable or a text file. The user will configure the proper
value when installing the registration agent into their application;</p></li>
<li><p>app_name - string - the name of the application. This is used to identify the application in the
web interface. The value is usually available from ENV variable;</p></li>
<li><p>app_uuid - string - a unique identifier of the application on the cloud platform. Some platforms
do not provide a real UUID. In such case you may use any unique string, for example $username-$appname;</p></li>
<li><p>app_type - string - type of the application, e.g. Python, Ruby, etc. Used for visualization in the
web interface. Some cloud vendors store this in ENV variable;</p></li>
<li><p>app_url - string - the URL at which the application can be accessed including the protocol part (http://).
Should be available from ENV;</p></li>
<li><p>app_vendor - integer - the vendor ID reserved by Monupco. This is used for proper identification
of applications in the web console and for processing purposes;</p></li>
<li><p>pkg_type - integer - the package type ID reserved by Monupco. This is used to properly process
package information and find new versions and updates. If the cloud platform allows only a single
type of packages to be installed into the application then use this variable. If you can install
multiple package types (e.g. Python and Ruby) then you can set this on a per-package basis;</p></li>
<li><p>installed - a list of {'n' : string, 'v' : string, 't' : integer} elements, where:</p>

<ul>
<li><p>n - string - package name as identified by a native package management tool (e.g. gem, pip, etc);</p></li>
<li><p>v - string - package version;</p></li>
<li><p>t - integer (optional) - package type ID reserved by Monupco. Define it here is multiple
package types are allowed and the current package is different from <code>pkg_type</code>.</p></li>
</ul>
</li>
<li><p>In some cloud platforms your application will be considered as a package and listed in the database
as well. You may use an ENV variable to ignore this name and not include it in the list;</p></li>
<li><p>The defined structure is converted into JSON format and URL escaped;</p></li>
<li><p>Assign the escaped JSON string to the <code>json_data</code> POST variable;</p></li>
<li><p>Send a POST request to https://$devel-server-url/application/register/;</p></li>
<li><p>When sending the request make sure to include a <code>User-agent</code> header. The <code>User-agent</code>
string must follow the format:</p>

<pre><code>  monupco-&lt;vendor&gt;-&lt;language&gt;/&lt;version&gt;
</code></pre></li>
<li><p>If using common packages include them in the <code>User-agent</code> string as follows:</p>

<pre><code>  monupco-&lt;vendor&gt;-&lt;language&gt;/&lt;version&gt; common-&lt;language&gt;-monupco/&lt;version&gt;
</code></pre>

<p>For more information about <code>User-aget</code> string format click
<a href="http://en.wikipedia.org/wiki/User_agent#Format">here</a>.</p></li>
<li><p>If everything went fine you will receive a 200 status code and response in JSON format:</p>

<pre><code>  {
      'message' : string,
      'exit_code' : integer
  }
</code></pre>

<ul>
<li><p>message - holds any pass/fail messages;</p></li>
<li><p>exit_code - non 0 in case of failure.</p></li>
</ul>
</li>
<li><p>Add a README file with instructions how to install. Pay attention to end-user configuration
settings and proper execution of the tool. The best place to place a call to
the registration script is a post_deploy/post_install hook. Some cloud platforms do not offer
hooks. In this case you may want to ping us for some help.</p></li>
</ul>


<p>Congratulations! You have just written a registration agent for your favorite PaaS and
programming language. Sent us the code for review and we will add it to our GitHub channel.</p>

<p>For more details you may take a look at <a href="https://github.com/monupco/monupco-openshift-express-python">https://github.com/monupco/monupco-openshift-express-python</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spinning-up a development instance on OpenShift Express]]></title>
    <link href="http://monupco.com/blog/2012/02/10/spinning-up-a-development-instance-on-openshift-express/"/>
    <updated>2012-02-10T21:19:00+02:00</updated>
    <id>http://monupco.com/blog/2012/02/10/spinning-up-a-development-instance-on-openshift-express</id>
    <content type="html"><![CDATA[<p><a href="http://monupco.com">Monupco</a> is hosted on <a href="http://openshift.redhat.com">OpenShift</a> Express.
During development we often need to spin-up another copy of Monupco to use for testing and development.
With OpenShift this is easy and fast. Here's how:</p>

<ol>
<li><p>Create another application on OpenShift. This will be your development instance.</p>

<pre><code> rhc-create-app -a myappdevel -t python-2.6
</code></pre></li>
<li><p>Find out the git URL for the production application:</p>

<pre><code> $ rhc-user-info
 Application Info
 ================
 myapp
     Framework: python-2.6
      Creation: 2012-02-10T12:39:53-05:00
          UUID: 723f0331e17041e8b34228f87a6cf1f5
       Git URL: ssh://723f0331e17041e8b34228f87a6cf1f5@myapp-mydomain.rhcloud.com/~/git/myapp.git/
    Public URL: http://myapp-mydomain.rhcloud.com/
</code></pre></li>
<li><p>Push the current code base from the production instance to devel instance:</p>

<pre><code> cd myappdevel
 git remote add production -m master ssh://723f0331e17041e8b34228f87a6cf1f5@myapp-mydomain.rhcloud.com/~/git/myapp.git/
 git pull -s recursive -X theirs production master
 git push
</code></pre></li>
<li><p>Now your <code>myappdevel</code> is the same as your production instance. You will probably want to
modify your database connection settings at this point and start adding new features.</p></li>
</ol>

]]></content>
  </entry>
  
</feed>
