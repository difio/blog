<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Amazon | Difio]]></title>
  <link href="http://dif.io/blog/categories/amazon/atom.xml" rel="self"/>
  <link href="http://dif.io/blog/"/>
  <updated>2012-07-31T22:01:50+03:00</updated>
  <id>http://dif.io/blog/</id>
  <author>
    <name><![CDATA[Difio Team]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cross-domain AJAX served from CDN]]></title>
    <link href="http://dif.io/blog/2012/05/19/cross-domain-ajax-served-from-cdn/"/>
    <updated>2012-05-19T16:58:00+03:00</updated>
    <id>http://dif.io/blog/2012/05/19/cross-domain-ajax-served-from-cdn</id>
    <content type="html"><![CDATA[<p>This week Amazon <a href="http://aws.typepad.com/aws/2012/05/amazon-cloudfront-support-for-dynamic-content.html">announced</a>
support for dynamic content in their CDN solution <a href="http://aws.amazon.com/cloudfront/"><em>Amazon CloudFront</em></a>.
The announce coincided with my efforts to migrate more pieces of <em>Difio</em>'s <a href="http://www.dif.io">website</a> to <em>CloudFront</em>.</p>

<p>In this article I will not talk about hosting static files on CDN. This is easy and I've already written
about it <a href="/2012/04/17/using-openshift-as-amazon-cloudfront-origin-server/">here</a>. I will show how to
cache AJAX(JSONP actually) responses and serve them directly from <em>Amazon CloudFront</em>.</p>

<h2>Background</h2>

<p>For those if you who may not be familiar (are there any) CDN stands for
<a href="https://en.wikipedia.org/wiki/Content_delivery_network">Content Delivery Network</a>. In short
this employs numerous servers with identical content. The requests from the browser are served
from the location which gives best performance for the user. This is used by all major websites
to speed-up static content like images, video, CSS and JavaScript files.</p>

<p>AJAX means <a href="https://en.wikipedia.org/wiki/Ajax_%28programming%29">Asynchronous JavaScript and XML</a>.
This is what Google uses to create dynamic user interface which doesn't require to reload the page.</p>

<h2>Architecture</h2>

<p><em>Difio</em> has two web interfaces. The primary one is a static HTML website
which employs JavaScript for the dynamic areas. It is hosted on the dif.io domain.
The other one is powered by Django and provides the same interface plus the
<a href="https://difio-otb.rhcloud.com/applications/mine/">applications dashboard</a> and several API functions
which don't have a visible user interface. This is under the *.rhcloud.com domain b/c it is hosted on
<a href="http://openshift.redhat.com"><em>OpenShift</em></a>.</p>

<p>The present state of the website is the result of rapid development using conventional methods -
HTML templates and server-side processing. This is migrating to modern web technology like static HTML
and JavaScript while the server side will remain pure API service.</p>

<p>For this migration to happen I need the HTML pages at dif.io to execute JavaScript and load information
which comes from the rhcloud.com domain. Unfortunately this is not easily doable with AJAX because
of the <a href="https://en.wikipedia.org/wiki/Same_origin_policy">Same origin policy</a> in browsers.</p>

<p>I'm using the <a href="http://dojotoolkit.org/"><em>Dojo Toolkit</em></a> JavaScript framework which has a solution.
It's called <a href="https://en.wikipedia.org/wiki/JSONP">JSONP</a>. Here's how it works:</p>

<pre><code>     dif.io ------ JSONP request --&gt; abc.rhcloud.com --v
        ^                                              |
        |                                              |
    JavaScript processing                              |
        |                                              |
        +------------------ JSONP response ------------+
</code></pre>

<p>This is pretty standard configuration for a web service.</p>

<h2>Going to the clouds</h2>

<p>The way <em>Dojo</em> implements JSONP is through the
<a href="http://dojotoolkit.org/reference-guide/1.7/dojo/io/script.html">dojo.io.script</a> module.
It works by appending a query string parameter of the form <em>?callback=funcName</em> which the server uses
to generate the JSONP response. This callback name is dynamically generated by <em>Dojo</em> based on the order
in which your call to <em>dojo.io.script</em> is executed.</p>

<p>Until recently <em>Amazon CloudFront</em> ignored all query string parameters when requesting the content from
the origin server. Without the query string it was not possible to generate the JSONP response.
Luckily Amazon resolved the issue only one day after I asked about it on their forums.</p>

<p>Now <em>Amazon CloudFront</em> will use the URL path and the query string parameters to identify the objects in cache.
To enable this edit the CloudFront distribution <em>behavior(s)</em> and set <em>Forward Query Strings</em> to Yes.</p>

<p>When a visitor of the website requests the data <em>Amazon CloudFront</em> will use exactly the same url path and query strings
to fetch the content from the origin server. All that I had to do is switch the domain of the JSONP service
to point to the cloudfront.net domain. It became like this:</p>

<pre><code>                                                        | Everything on this side is handled by Amazon.
                                                        | No code required!
                                                        |
     dif.io ------ JSONP request --&gt; xyz.cloudfront.net -- JSONP request if cache miss --&gt; abc.rhcloud.com --v
        ^                              |                ^                                                    |
        |                              |                |                                                    |
    JavaScript processing              |                +---------- JSONP response --------------------------+
        |                              |
        +---- cached JSONP response ---+
</code></pre>

<p>As you can see the website structure and code didn't change at all. All that changed was a single domain name.</p>

<h2>Controlling the cache</h2>

<p><em>Amazon CloudFront</em> will keep the contents in cache based on the origin headers if present or the manual configuration
from the AWS Console. To work around frequent requests to the origin server it is considered best practice to set the
Expires header to a value far in the future, like 1 year.
However if the content changes you need some way to tell <em>CloudFront</em> about it. The most commonly used method is through
using different URLs to access the same content. This will cause <em>CloudFront</em> to cache the content under the new location
while keeping the old content until it expires.</p>

<p><em>Dojo</em> makes this very easy:</p>

<pre><code>    require(["dojo/io/script"],
        function(script) {
                script.get({
                    url: "https://xyz.cloudfront.net/api/json/updates/1234",
                    callbackParamName: "callback",
                    content: {t: timeStamp},
                    load: function(jsonData) {
                        ....
                    },
    ....
</code></pre>

<p>The <em>content</em> property allows additional key/value pairs to be sent in the query string. The
<em>timeStamp</em> parameter serves only to control <em>Amazon CloudFront</em> cache. It's not processed server side.</p>

<p>On the server-side we have:</p>

<pre><code>    response['Cache-Control'] = 'max-age=31536000'
    response['Expires'] = (datetime.now()+timedelta(seconds=31536000)).strftime('%a, %d %b %Y %H:%M:%S GMT')
</code></pre>

<h2>Benefits</h2>

<p>There were two immediate benefits:</p>

<ul>
<li>Reduced page load time. Combined with serving static files from CDN this greatly improves the user experience;</li>
<li>Reduced server load. Content is requested only once if it is missing from the cache and then served from CloudFront.
The server isn't so busy serving content so it can be used to do more computations or simply reduce the bill.</li>
</ul>


<p>The presented method works well for <em>Difio</em> because of two things:</p>

<ul>
<li>The content which <em>Difio</em> serves usually doesn't change at all once made public. In rare occasions, for example an error
has been published, we have to regenerate new content and publish it under the same URL.</li>
<li>Before content is made public it is inspected for errors and this also preseeds the cache.</li>
</ul>


<hr />

<p><a href="http://about.me/atodorov"><em>Alexander Todorov</em></a> is Difio's founder and lead developer!</p>

<p>For an insight of available updates to your open source components give
Difio a <a href="https://difio-otb.rhcloud.com/applications/mine/">try</a>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using OpenShift as Amazon CloudFront origin server]]></title>
    <link href="http://dif.io/blog/2012/04/17/using-openshift-as-amazon-cloudfront-origin-server/"/>
    <updated>2012-04-17T17:30:00+03:00</updated>
    <id>http://dif.io/blog/2012/04/17/using-openshift-as-amazon-cloudfront-origin-server</id>
    <content type="html"><![CDATA[<p>It's been several months after the start of <a href="http://www.dif.io"><em>Difio</em></a> and we started
migrating various parts of the platform to CDN. The first to go are static 01 like
CSS, JavaScript, images and such. In this article I will show you how to get started with
<em>Amazon CloudFront</em> and <em>OpenShift</em>. It is very easy once you understand how it works.</p>

<h2>Why CloudFront and OpenShift</h2>

<p><em>Amazon CloudFront</em> is cheap and easy to setup with virtually no maintenance.
The most important feature 04 that it can fetch content from any public website.
Integrating it together with <em>OpenShift</em> gives some nice benefits:</p>

<ul>
<li>All static assets are managed with Git and stored in the same place where the application
code and HTML is - easy to develop and deploy;</li>
<li>No need for external service to host the static files;</li>
<li><em>CloudFront</em> will be serving the files so network load on <em>OpenShift</em> is minimal;</li>
<li>Easy to manage versioned URLs because HTML and static assets are in the same repo - more on this later;</li>
</ul>


<h2>Object expiration</h2>

<p><em>CloudFront</em> will cache your objects for a certain period and then expire them. Frequently
used objects are expired less often. Depending on the content you may want to update the cache
more or less frequently. In my case CSS and JavaScript files change rarely so I wanted to tell
CloudFront to not expire the files quickly. I did this by telling <em>Apache</em> to send a custom value for
the Expires header.</p>

<pre><code>    $ curl http://d71ktrt2emu2j.cloudfront.net/static/v1/css/style.css -D headers.txt
    $ cat headers.txt 
    HTTP/1.0 200 OK
    Date: Mon, 16 Apr 2012 19:02:16 GMT
    Server: Apache/2.2.15 (Red Hat)
    Last-Modified: Mon, 16 Apr 2012 19:00:33 GMT
    ETag: "120577-1b2d-4bdd06fc6f640"
    Accept-Ranges: bytes
    Content-Length: 6957
    Cache-Control: max-age=31536000
    Expires: Tue, 16 Apr 2013 19:02:16 GMT
    Content-Type: text/css
    Strict-Transport-Security: max-age=15768000, includeSubDomains
    Age: 73090
    X-Cache: Hit from cloudfront
    X-Amz-Cf-Id: X558vcEOsQkVQn5V9fbrWNTdo543v8VStxdb7LXIcUWAIbLKuIvp-w==,e8Dipk5FSNej3e0Y7c5ro-9mmn7OK8kWfbaRGwi1ww8ihwVzSab24A==
    Via: 1.0 d6343f267c91f2f0e78ef0a7d0b7921d.cloudfront.net (CloudFront)
    Connection: close
</code></pre>

<p>All headers before Strict-Transport-Security come from the origin server.</p>

<h2>Versioning</h2>

<p>Sometimes however you need to update the files and force <em>CloudFront</em> to update the content.
The recommended way to do this is to use URL versioning and update the path to the files
which changed. This will force <em>CloudFront</em> to cache and serve the content under the new path
while keeping the old content available until it expires. This way your visitors will not be
viewing your site with the new CSS and old JavaScript.</p>

<p>There are many ways to do this and there are some nice frameworks as well. For Python there is <em>webassets</em>.
I don't have many static files so I opted for no additional dependencies. Instead I will be updating the
versions by hand.</p>

<p>What comes to mind is using <em>mod_rewrite</em> to redirect the versioned URLs back to non versioned ones.
However there's a catch. If you do this <em>CloudFront</em> will cache the redirect itself, not the content.
The next time visitors hit <em>CloudFront</em> they will receive the cached redirect and follow it back to your
origin server, which is defeating the purpose of having CDN.</p>

<p>To do it properly you have to rewrite the URLs but still return a 200 response code and the
content which needs to be cached. This is done with <em>mod_proxy</em>:</p>

<pre><code>    RewriteEngine on
    RewriteRule ^VERSION-(\d+)/(.*)$ http://%{ENV:OPENSHIFT_INTERNAL_IP}:%{ENV:OPENSHIFT_INTERNAL_PORT}/static/$2 [P,L]
</code></pre>

<p>This .htaccess trick doesn't work on <em>OpenShift</em> though. <em>mod_proxy</em> is not enabled at the moment.
See <a href="https://bugzilla.redhat.com/show_bug.cgi?id=812389">bug 812389</a> for more info.</p>

<p>Luckily I was able to use symlinks to point to the content. Here's how it looks:</p>

<pre><code>    $ pwd
    /home/atodorov/difio/wsgi/static

    $ cat .htaccess
    ExpiresActive On
    ExpiresDefault "access plus 1 year"

    $ ls -l
    drwxrwxr-x. 6 atodorov atodorov 4096 16 Apr 21,31 o
    lrwxrwxrwx. 1 atodorov atodorov    1 16 Apr 21,47 v1 -&gt; o

    settings.py:
    STATIC_URL = '//d71ktrt2emu2j.cloudfront.net/static/v1/'

    HTML template:
    &lt;link type="text/css" rel="stylesheet" media="screen" href="{{ STATIC_URL }}css/style.css" /&gt;
</code></pre>

<h2>How to implement it</h2>

<p>First you need to split all CSS and JavaScript from your HTML if you haven't done so already.</p>

<p>Then place everything under your git repo so that <em>OpenShift</em> will serve the files. For Python applications
place the files under wsgi/static/ directory in your git repo.</p>

<p>Point all of your HTML templates to the static location on <em>OpenShift</em> and test if everything works as expected.
This is best done if you're using some sort of template language and store the location
in a single variable which you can change later.
<em>Difio</em> uses <em>Django</em> and the <em>STATIC_URL</em> variable of course.</p>

<p>Create your <em>CloudFront</em> distribution - don't use <em>Amazon S3</em>, instead configure a custom origin server. Write down
your <em>CloudFront</em> URL. It will be something like <strong>1234xyz.cludfront.net</strong>.</p>

<p>Every time a request hits <em>CloudFront</em> it will check if the object is present in the cache. If not present
<em>CloudFront</em> will fetch the object from the origin server and populate the cache. Then the object is sent
to the user.</p>

<p>Update your templates to point to the new cloudfront.net URL and redeploy your website!</p>

<hr />

<p><a href="http://about.me/atodorov"><em>Alexander Todorov</em></a> is Difio's founder and lead developer!</p>

<p>For an insight of available updates to you OpenShift applications give
Difio a <a href="https://difio-otb.rhcloud.com/applications/mine/">try</a>!</p>
]]></content>
  </entry>
  
</feed>
